# è®¾è®¡ 009: é›¶çŸ¥è¯†éšç§æ¶æ„ (ZK Privacy Architecture)

> çŠ¶æ€: è§„åˆ’ä¸­ (V3 Target)
> æ ¸å¿ƒæˆ˜ç•¥: **Zig as a ZK DSL**ã€‚é€šè¿‡è½¬è¯‘æŠ€æœ¯ï¼Œè®©å¼€å‘è€…ä½¿ç”¨ Zig ç¼–å†™ç”µè·¯ã€‚
> ç›®æ ‡è¯­è¨€: **Noir** (Aztec Labs)

## 0. æˆ˜ç•¥èƒŒæ™¯ï¼šæ·±å…¥ç†è§£ Noir

### 0.1 å…³é”®æ¾„æ¸…ï¼šNoir ä¸æ˜¯ zkEVM æ™ºèƒ½åˆçº¦è¯­è¨€

> **å¸¸è§è¯¯åŒº**: Noir æ˜¯ç”¨æ¥å†™æ™ºèƒ½åˆçº¦çš„ã€‚
>
> **äº‹å®**: **é”™ï¼** Noir æ˜¯ç”¨æ¥å†™ **ZK ç”µè·¯** çš„ã€‚

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Noir çš„çœŸå®å®šä½                                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  Noir = ZK Circuit DSL (ç±»ä¼¼ Circomï¼Œä½† Rust é£æ ¼è¯­æ³•)                     â”‚
â”‚                                                                           â”‚
â”‚  è¾“å…¥: Noir ä»£ç                                                           â”‚
â”‚  è¾“å‡º:                                                                    â”‚
â”‚    1. ACIR (Abstract Circuit Intermediate Representation)                 â”‚
â”‚    2. å¯é€‰: Solidity Verifier åˆçº¦ (è‡ªåŠ¨ç”Ÿæˆ!)                            â”‚
â”‚                                                                           â”‚
â”‚  ç”¨é€”: ä»»ä½•éœ€è¦ ZK Proof çš„åœºæ™¯                                           â”‚
â”‚    â€¢ éšç§ç©ºæŠ• (è¯æ˜èµ„æ ¼ï¼Œä¸æš´éœ²åœ°å€)                                       â”‚
â”‚    â€¢ èº«ä»½éªŒè¯ (è¯æ˜å¹´é¾„ > 18ï¼Œä¸æš´éœ²ç”Ÿæ—¥)                                  â”‚
â”‚    â€¢ è®¡ç®—å®Œæ•´æ€§ (è¯æ˜ AI æ¨ç†ç»“æœæ­£ç¡®)                                     â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 0.2 Noir å·¥ä½œæµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         Noir å®Œæ•´æµç¨‹                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  1. å¼€å‘é˜¶æ®µ                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚     â”‚  Noir    â”‚ â”€â”€â”€â–º â”‚  nargo   â”‚ â”€â”€â”€â–º â”‚  ACIR Circuit      â”‚        â”‚
â”‚     â”‚  ä»£ç     â”‚      â”‚  compile â”‚      â”‚  (JSON/Binary)     â”‚        â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                 â”‚                       â”‚
â”‚                                                 â–¼                       â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚                              â”‚  Solidity Verifier (è‡ªåŠ¨ç”Ÿæˆ)   â”‚       â”‚
â”‚                              â”‚  UltraPlonkVerifier.sol         â”‚       â”‚
â”‚                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚                                                                         â”‚
â”‚  2. è¿è¡Œé˜¶æ®µ                                                             â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚     â”‚  Private â”‚      â”‚  nargo   â”‚      â”‚  ZK Proof          â”‚        â”‚
â”‚     â”‚  Inputs  â”‚ â”€â”€â”€â–º â”‚  prove   â”‚ â”€â”€â”€â–º â”‚  (bytes)           â”‚        â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚                                                 â”‚                       â”‚
â”‚                                                 â–¼                       â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚     â”‚  On-Chain: verifier.verify(proof, publicInputs) â†’ bool   â”‚     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 0.3 ä¸ºä»€ä¹ˆ Noir æ˜¯ Titan çš„æœ€ä½³é€‰æ‹©

| ç‰¹æ€§ | Noir | Circom | Leo (Aleo) |
| :--- | :---: | :---: | :---: |
| **è¯­æ³•é£æ ¼** | Rust-like | ç±» JS | è‡ªå®šä¹‰ |
| **å­¦ä¹ æ›²çº¿** | â­â­ | â­â­â­ | â­â­â­â­ |
| **è‡ªåŠ¨ç”Ÿæˆ Solidity** | âœ… | âŒ (æ‰‹åŠ¨) | âŒ |
| **ç”Ÿæ€æˆç†Ÿåº¦** | é«˜ (Aztec) | é«˜ | ä¸­ |
| **ä¸ Zig ç›¸ä¼¼åº¦** | é«˜ | ä½ | ä½ |

**å…³é”®**: Noir çš„ Rust-like è¯­æ³•ä½¿å¾— Zig â†’ Noir è½¬è¯‘**è‡ªç„¶ä¸”ç›´è§‚**ã€‚

### 0.4 Noir åœ¨ Titan æ¶æ„ä¸­çš„ä½ç½®

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Titan ä¸‰å¤§ç¼–è¯‘è·¯å¾„                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                         â”‚
â”‚  è·¯å¾„ A: LLVM åŸç”Ÿç¼–è¯‘ (æ™ºèƒ½åˆçº¦)                                         â”‚
â”‚  â”œâ”€â”€ Solana (SBF)                                                       â”‚
â”‚  â”œâ”€â”€ Near/Cosmos/Polkadot (Wasm)                                        â”‚
â”‚  â””â”€â”€ CKB (RISC-V)                                                       â”‚
â”‚                                                                         â”‚
â”‚  è·¯å¾„ B: æºå¯¹æºè½¬è¯‘ (æ™ºèƒ½åˆçº¦)                                            â”‚
â”‚  â”œâ”€â”€ TON â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Fift â”€â”€â”€â”€â”€â”€â”€â”€â–º TVM                               â”‚
â”‚  â”œâ”€â”€ EVM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Yul â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º EVM Bytecode                      â”‚
â”‚  â””â”€â”€ BTC â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Miniscript â”€â”€â–º Bitcoin Script                    â”‚
â”‚                                                                         â”‚
â”‚  è·¯å¾„ C: ZK ç”µè·¯ç¼–è¯‘ (éšç§/éªŒè¯)  â† æœ¬æ–‡æ¡£                                â”‚
â”‚  â””â”€â”€ ZK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º Noir â”€â”€â”€â”€â”€â”€â”€â”€â–º ACIR + Solidity Verifier          â”‚
â”‚                                                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**å…³é”®æ´å¯Ÿ**: Noir ä¸æ˜¯ç”¨æ¥æ›¿ä»£ Yul æˆ– Fift çš„ï¼Œè€Œæ˜¯**æ­£äº¤çš„å¦ä¸€ç»´åº¦**â€”â€”éšç§ä¸å¯éªŒè¯è®¡ç®—ã€‚

## 1. ç»ˆææ„¿æ™¯

æˆ‘ä»¬ä¸å¼ºåˆ¶å¼€å‘è€…å­¦ä¹  Noir æˆ– Circomã€‚Titan OS çš„ç¼–è¯‘å™¨å°†æ”¯æŒæŠŠ Zig ä»£ç çš„ä¸€ä¸ªå—é™å­é›† (**Titan-Z**) è½¬è¯‘ä¸º **Noir** ä»£ç ã€‚

**Write Circuits in Zig.**

## 2. æ ‡æ³¨ä¸å¯¼å‡ºæœºåˆ¶ (Annotation & Export)

Titan OS é‡‡ç”¨ **â€œæ–‡æ¡£æ³¨é‡Šè¯´æ˜ + ç¼–è¯‘æ—¶æ˜¾å¼å¯¼å‡ºâ€** çš„åŒé‡æœºåˆ¶ï¼Œç¡®ä¿ ZK ç”µè·¯æ—¢æ˜“äºé˜…è¯»ï¼Œåˆå—åˆ° Zig ç±»å‹ç³»ç»Ÿçš„ä¸¥æ ¼çº¦æŸã€‚

### 2.1 æ ‡æ³¨è§„èŒƒ (The Hybrid Standard)

1.  **Doc Comment (`/// @zk_circuit`)**: ç”¨äºæ ‡è®°å‡½æ•°ä¸ºç”µè·¯ï¼Œå¹¶æä¾›ç»™è½¬è¯‘å™¨ï¼ˆTranspilerï¼‰è§£æã€‚
2.  **Comptime Export**: ç”¨æˆ·å¿…é¡»åœ¨ä¸€ä¸ªå…¬å…±å¸¸é‡ä¸­å¯¼å‡ºç”µè·¯å‡½æ•°ï¼Œä»¥ä¾¿æ„å»ºç³»ç»Ÿï¼ˆBuild Systemï¼‰èƒ½å¤Ÿå‡†ç¡®è¯†åˆ«å…¥å£ã€‚

### 2.2 ä»£ç ç¤ºä¾‹

```zig
const std = @import("std");
const zk = @import("titan.zk");

/// @zk_circuit
/// è¿™æ˜¯ä¸€ä¸ªéªŒè¯ç”¨æˆ·å¯†ç å“ˆå¸Œçš„ç”µè·¯ã€‚
/// é™åˆ¶ï¼šè¾“å…¥å¿…é¡»æ˜¯ 256 ä½å­—æ®µå…ƒç´ ã€‚
pub fn check_password(public_hash: u256, secret_password: u256) bool {
    const computed = zk.hash(secret_password);
    return computed == public_hash;
}

// æ˜¾å¼å¯¼å‡ºï¼šTitan CLI å°†æ‰«ææ­¤å¸¸é‡
pub const __titan_zk_circuits = .{
    .verify_password = check_password,
};
```

## 3. æ¶æ„æµç¨‹ (The Transpilation Pipeline)

1.  **æ‰«æ (Scan)**: Titan CLI æ‰«æ `src/` ä¸‹æ‰€æœ‰å¯¼å‡ºäº† `__titan_zk_circuits` çš„æ–‡ä»¶ã€‚
2.  **éªŒè¯ (Verify)**: åˆ©ç”¨ Zig ç¼–è¯‘å™¨çš„ `ast-check` éªŒè¯è¯­æ³•ï¼Œå¹¶æ ¹æ® Doc Comment æå–å…ƒæ•°æ®ã€‚
3.  **è½¬è¯‘ (Transpile)**: å°† Zig AST çš„å—é™å­é›†è½¬è¯‘ä¸º Noir æºç  (`.nr`)ã€‚
4.  **ç¼–è¯‘ (Build)**: è°ƒç”¨ `nargo` ç”Ÿæˆ ACIRã€‚

## 4. è¯­ä¹‰æ˜ å°„ (Semantic Mapping)

### 4.1 åŸºç¡€ç±»å‹æ˜ å°„

| Zig ç±»å‹ | Noir æ˜ å°„ | è¯´æ˜ |
| :--- | :--- | :--- |
| `u8/u16/u32/u64` | `u8/u16/u32/u64` | ç›´æ¥æ˜ å°„ |
| `u256` | `Field` | 254-bit æœ‰é™åŸŸå…ƒç´  |
| `bool` | `bool` | ç›´æ¥æ˜ å°„ |
| `[N]T` | `[N; T]` | å›ºå®šé•¿åº¦æ•°ç»„ |
| `struct` | `struct` | æ— æŒ‡é’ˆå¼•ç”¨ |

### 4.2 æ§åˆ¶æµæ˜ å°„

| Zig ä»£ç  | Noir æ˜ å°„ | é™åˆ¶ |
| :--- | :--- | :--- |
| `if (cond) a else b` | `if cond { a } else { b }` | å¿…é¡»å¯å±•å¼€ä¸º Mux é—¨ |
| `inline for (0..N)` | `for i in 0..N` | å¾ªç¯æ¬¡æ•°å¿…é¡»ç¼–è¯‘æ—¶ç¡®å®š |
| `switch (x)` | `if ... else if ...` | å±•å¼€ä¸ºæ¡ä»¶é“¾ |
| `while` | âŒ ä¸æ”¯æŒ | ä¸ç¡®å®šè¿­ä»£æ¬¡æ•° |

### 4.3 å‡½æ•°ä¸å¯è§æ€§æ˜ å°„

| Zig ä»£ç  | Noir æ˜ å°„ | è¯´æ˜ |
| :--- | :--- | :--- |
| `pub fn main()` | `fn main()` | å…¥å£ç‚¹ |
| `fn helper()` | `fn helper()` | å†…éƒ¨å‡½æ•° |
| `å‚æ•°: T` | `x: T` (private) | é»˜è®¤ç§æœ‰è¾“å…¥ |
| `/// @public` æ ‡æ³¨ | `x: pub T` | å…¬å¼€è¾“å…¥ |

### 4.4 ZK ç‰¹æœ‰æ¦‚å¿µæ˜ å°„

| Zig SDK | Noir åŸè¯­ | è¯´æ˜ |
| :--- | :--- | :--- |
| `zk.hash(x)` | `std::hash::pedersen_hash([x])` | Pedersen å“ˆå¸Œ |
| `zk.merkle_proof(...)` | `std::merkle::verify_proof(...)` | Merkle è¯æ˜ |
| `zk.assert(cond)` | `assert(cond)` | çº¦æŸæ–­è¨€ |
| `zk.range_check(x, bits)` | `x.assert_max_bit_size(bits)` | èŒƒå›´æ£€æŸ¥ |

### 4.5 ä»£ç ç¤ºä¾‹å¯¹æ¯”

**Zig æºç **:
```zig
const zk = @import("titan.zk");

/// @zk_circuit
pub fn verify_merkle_membership(
    /// @public
    root: u256,
    leaf: u256,
    path: [32]u256,
    indices: [32]u1,
) bool {
    var computed = zk.hash(leaf);

    inline for (0..32) |i| {
        const sibling = path[i];
        if (indices[i] == 0) {
            computed = zk.hash_pair(computed, sibling);
        } else {
            computed = zk.hash_pair(sibling, computed);
        }
    }

    return computed == root;
}
```

**ç”Ÿæˆçš„ Noir ä»£ç **:
```rust
use dep::std;

fn main(
    root: pub Field,      // @public æ ‡æ³¨ â†’ pub
    leaf: Field,          // é»˜è®¤ç§æœ‰
    path: [Field; 32],
    indices: [u1; 32],
) {
    let mut computed = std::hash::pedersen_hash([leaf]);

    for i in 0..32 {
        let sibling = path[i];
        if indices[i] == 0 {
            computed = std::hash::pedersen_hash([computed, sibling]);
        } else {
            computed = std::hash::pedersen_hash([sibling, computed]);
        }
    }

    assert(computed == root);
}
```

## 5. ä»·å€¼ä¸»å¼ 

è¿™æ˜¯ Titan OS ç»Ÿä¸€ä½“éªŒçš„æœ€åä¸€å—æ‹¼å›¾ã€‚
*   **ç»Ÿä¸€è¯­è¨€**: åˆçº¦ç”¨ Zigï¼Œé©±åŠ¨ç”¨ Zigï¼Œå·¥å…·ç”¨ Zigï¼Œ**ç°åœ¨è¿ç”µè·¯ä¹Ÿç”¨ Zig**ã€‚
*   **å·¥å…·å¤ç”¨**: å¤ç”¨ Zig çš„ LSP (è‡ªåŠ¨è¡¥å…¨ã€è·³è½¬)ï¼Œä¸éœ€è¦ä¸º Noir å•ç‹¬é…ç½®ç¼–è¾‘å™¨ç¯å¢ƒã€‚

## 6. ç«¯åˆ°ç«¯ç¤ºä¾‹ï¼šZK ç©ºæŠ• (ZK Airdrop)

### 6.1 é—®é¢˜åœºæ™¯

ä¼ ç»Ÿç©ºæŠ•çš„éšç§é—®é¢˜ï¼š
- ç™½åå•å…¬å¼€ â†’ åœ°å€å…³è”åˆ†æ
- é¢†å–è¡Œä¸ºæš´éœ² â†’ é“¾ä¸Šæ´»åŠ¨è¿½è¸ª

**ZK ç©ºæŠ•ç›®æ ‡**: ç”¨æˆ·è¯æ˜è‡ªå·±åœ¨ç™½åå•ä¸­ï¼Œä½†**ä¸æš´éœ²è‡ªå·±æ˜¯å“ªä¸ªåœ°å€**ã€‚

### 6.2 å®Œæ•´ä»£ç ç¤ºä¾‹

**Step 1: å®šä¹‰ ZK ç”µè·¯ (Zig)**

```zig
// src/circuits/airdrop_eligibility.zig
const zk = @import("titan.zk");

/// @zk_circuit
/// è¯æ˜ç”¨æˆ·æœ‰èµ„æ ¼é¢†å–ç©ºæŠ•ï¼Œä½†ä¸æš´éœ²å…·ä½“æ˜¯å“ªä¸ªç™½åå•åœ°å€
pub fn prove_eligibility(
    /// @public - ç™½åå• Merkle æ ¹ (æ‰€æœ‰äººå¯è§)
    whitelist_root: u256,
    /// @public - å½“å‰é¢†å–è€…çš„æ–°åœ°å€ (ç”¨äºæ¥æ”¶ç©ºæŠ•)
    recipient: u256,
    /// @public - é˜²æ­¢åŒé‡é¢†å–çš„ nullifier
    nullifier: u256,

    // ===== ä»¥ä¸‹ä¸ºç§æœ‰è¾“å…¥ =====
    /// ç”¨æˆ·çš„åŸå§‹ç™½åå•åœ°å€ (ç§æœ‰ï¼Œä¸æš´éœ²)
    secret_address: u256,
    /// ç”¨æˆ·çš„ç§˜å¯†ç›å€¼ (ç”¨äºç”Ÿæˆ nullifier)
    secret_salt: u256,
    /// Merkle è¯æ˜è·¯å¾„
    merkle_path: [32]u256,
    /// è·¯å¾„æ–¹å‘ç´¢å¼•
    path_indices: [32]u1,
) bool {
    // 1. éªŒè¯ nullifier æ­£ç¡®ç”Ÿæˆ (é˜²æ­¢åŒé‡é¢†å–)
    const expected_nullifier = zk.hash_pair(secret_address, secret_salt);
    zk.assert(nullifier == expected_nullifier);

    // 2. è®¡ç®—å¶å­èŠ‚ç‚¹ (ç™½åå•åœ°å€çš„å“ˆå¸Œ)
    const leaf = zk.hash(secret_address);

    // 3. éªŒè¯ Merkle è¯æ˜ (è¯æ˜åœ°å€åœ¨ç™½åå•ä¸­)
    var computed_root = leaf;
    inline for (0..32) |i| {
        const sibling = merkle_path[i];
        if (path_indices[i] == 0) {
            computed_root = zk.hash_pair(computed_root, sibling);
        } else {
            computed_root = zk.hash_pair(sibling, computed_root);
        }
    }

    // 4. éªŒè¯è®¡ç®—å‡ºçš„æ ¹ä¸å…¬å¼€çš„ç™½åå•æ ¹ä¸€è‡´
    return computed_root == whitelist_root;
}

// å¯¼å‡ºç”µè·¯
pub const __titan_zk_circuits = .{
    .airdrop_eligibility = prove_eligibility,
};
```

**Step 2: é“¾ä¸ŠéªŒè¯åˆçº¦ (Zig â†’ Solana/EVM)**

```zig
// src/contracts/airdrop.zig
const titan = @import("titan");

pub const AirdropContract = struct {
    whitelist_root: u256,
    used_nullifiers: titan.Set(u256),
    token_address: titan.Address,
    airdrop_amount: u64,

    pub fn claim(
        ctx: *titan.Context,
        proof: []const u8,
        public_inputs: PublicInputs,
    ) !void {
        const self = try ctx.load(AirdropContract);

        // 1. éªŒè¯ç™½åå•æ ¹ä¸€è‡´
        if (public_inputs.whitelist_root != self.whitelist_root) {
            return error.InvalidRoot;
        }

        // 2. æ£€æŸ¥ nullifier æœªä½¿ç”¨ (é˜²æ­¢åŒé‡é¢†å–)
        if (self.used_nullifiers.contains(public_inputs.nullifier)) {
            return error.AlreadyClaimed;
        }

        // 3. éªŒè¯ ZK è¯æ˜
        const verifier = titan.zk.Verifier.load("airdrop_eligibility");
        if (!try verifier.verify(proof, public_inputs)) {
            return error.InvalidProof;
        }

        // 4. æ ‡è®° nullifier å·²ä½¿ç”¨
        try self.used_nullifiers.insert(public_inputs.nullifier);

        // 5. è½¬è´¦ç©ºæŠ•ä»£å¸
        try titan.token.transfer(
            self.token_address,
            public_inputs.recipient,
            self.airdrop_amount,
        );

        titan.log("Airdrop claimed successfully");
    }
};
```

**Step 3: ç¼–è¯‘ä¸éƒ¨ç½²**

```bash
# 1. ç¼–è¯‘ ZK ç”µè·¯ (Zig â†’ Noir â†’ ACIR)
titan-zk compile src/circuits/airdrop_eligibility.zig -o build/

# è¾“å‡º:
#   build/airdrop_eligibility.nr     (Noir æºç )
#   build/airdrop_eligibility.acir   (ç”µè·¯)
#   build/AirdropVerifier.sol        (Solidity éªŒè¯å™¨)

# 2. ç¼–è¯‘é“¾ä¸Šåˆçº¦
titan-solana compile src/contracts/airdrop.zig -o build/airdrop.so

# æˆ– EVM ç‰ˆæœ¬
titan-evm compile src/contracts/airdrop.zig -o build/airdrop.yul
```

### 6.3 ç”¨æˆ·é¢†å–æµç¨‹

```
ç”¨æˆ· (é“¾ä¸‹)                    åˆçº¦ (é“¾ä¸Š)
    â”‚                              â”‚
    â”‚  1. æœ¬åœ°ç”Ÿæˆè¯æ˜             â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚  â”‚ secret_address   â”‚       â”‚
    â”‚  â”‚ secret_salt      â”‚       â”‚
    â”‚  â”‚ merkle_path      â”‚       â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â”‚           â”‚                  â”‚
    â”‚           â–¼                  â”‚
    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
    â”‚  â”‚   Noir Prover    â”‚       â”‚
    â”‚  â”‚   (æœ¬åœ°æ‰§è¡Œ)     â”‚       â”‚
    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
    â”‚           â”‚                  â”‚
    â”‚           â–¼                  â”‚
    â”‚      ZK Proof                â”‚
    â”‚           â”‚                  â”‚
    â”‚  2. æäº¤è¯æ˜ + å…¬å¼€è¾“å…¥      â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€>â”‚
    â”‚                              â”‚
    â”‚                      3. éªŒè¯ ZK Proof
    â”‚                      4. æ£€æŸ¥ nullifier
    â”‚                      5. è½¬è´¦ä»£å¸
    â”‚                              â”‚
    â”‚  6. æ”¶åˆ°ç©ºæŠ•                 â”‚
    â”‚<â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
```

### 6.4 éšç§ä¿è¯

| ä¿¡æ¯ | é“¾ä¸Šå¯è§æ€§ | è¯´æ˜ |
| :--- | :---: | :--- |
| **ç™½åå•æ ¹** | å…¬å¼€ | ä¸æš´éœ²å…·ä½“åœ°å€ |
| **ç”¨æˆ·åŸå§‹åœ°å€** | âŒ ä¸å¯è§ | ZK ä¿æŠ¤ |
| **é¢†å–æ–°åœ°å€** | å…¬å¼€ | ç”¨æˆ·è‡ªé€‰ |
| **Nullifier** | å…¬å¼€ | æ— æ³•åæ¨åŸå§‹åœ°å€ |
| **é¢†å–é‡‘é¢** | å…¬å¼€ | ä¸šåŠ¡éœ€æ±‚ |

## 7. CLI å·¥å…·è®¾è®¡

```bash
# ===== ç”µè·¯å¼€å‘ =====

# ç¼–è¯‘ Zig ç”µè·¯åˆ° Noir
titan-zk compile <input.zig> -o <output_dir>

# ç”Ÿæˆ Solidity Verifier
titan-zk codegen verifier -i <circuit.acir> -o <Verifier.sol>

# ===== è¯æ˜ç”Ÿæˆ =====

# ç”Ÿæˆè¯æ˜ (éœ€è¦ç§æœ‰è¾“å…¥)
titan-zk prove <circuit.acir> -i <inputs.json> -o <proof.bin>

# éªŒè¯è¯æ˜ (æœ¬åœ°æµ‹è¯•)
titan-zk verify <circuit.acir> -p <proof.bin> -i <public_inputs.json>

# ===== æµ‹è¯• =====

# è¿è¡Œç”µè·¯æµ‹è¯•
titan-zk test src/circuits/

# ç”Ÿæˆæµ‹è¯•å‘é‡
titan-zk gen-test-vectors <circuit.acir> -o test_vectors.json
```

## 8. å¤‡é€‰æ–¹æ¡ˆ

å¦‚æœè½¬è¯‘éš¾åº¦è¿‡å¤§ï¼Œå›é€€åˆ° **"Inline Noir"** æ–¹æ¡ˆï¼š
åœ¨ Zig æ–‡ä»¶ä¸­é€šè¿‡å­—ç¬¦ä¸²å­—é¢é‡åµŒå…¥ Noir ä»£ç ï¼ˆç±»ä¼¼ Rust çš„ `asm!` å®ï¼‰ã€‚

```zig
// å¤‡é€‰æ–¹æ¡ˆ: å†…è” Noir
const noir_circuit = titan.zk.inline_noir(
    \\fn main(x: Field, y: pub Field) {
    \\    assert(x * x == y);
    \\}
);
```

## 9. å®ç°è·¯çº¿å›¾

### Phase 1: åŸºç¡€è®¾æ–½
- [ ] å®ç° Zig AST è§£æ (ZK å­é›†)
- [ ] å®ç° Noir ä»£ç ç”Ÿæˆå™¨
- [ ] é›†æˆ `nargo` å·¥å…·é“¾

### Phase 2: SDK å¼€å‘
- [ ] å®ç° `titan.zk` æ ‡å‡†åº“
- [ ] å®ç° Merkle è¯æ˜åŸè¯­
- [ ] å®ç°å“ˆå¸Œå‡½æ•°å°è£…

### Phase 3: é“¾ä¸Šé›†æˆ
- [ ] Solana Verifier Program æ¨¡æ¿
- [ ] EVM Verifier é›†æˆ (ä½¿ç”¨ Noir è‡ªåŠ¨ç”Ÿæˆ)
- [ ] ç«¯åˆ°ç«¯ Demo (ZK Airdrop)

### Phase 4: ç”Ÿæ€æ‰©å±•
- [ ] æ›´å¤šç”µè·¯æ¨¡æ¿ (æŠ•ç¥¨ã€èº«ä»½ã€èµ„æ ¼è¯æ˜)
- [ ] ä¸ Aztec Network åŸç”Ÿé›†æˆ
- [ ] æ€§èƒ½ä¼˜åŒ–ä¸åŸºå‡†æµ‹è¯•

## 10. ä¸å…¶ä»–è®¾è®¡çš„å…³ç³»

| è®¾è®¡æ–‡æ¡£ | å…³ç³» | è¯´æ˜ |
| :--- | :--- | :--- |
| **012_zk_compute_layer** | äº’è¡¥ | æœ¬æ–‡æ¡£ä¸“æ³¨ç”µè·¯ç¼–è¯‘ï¼Œ012 ä¸“æ³¨æ‰§è¡Œå±‚ |
| **020_adapter_evm_native** | ä¾èµ– | Verifier éƒ¨ç½²åˆ° EVM éœ€è¦ Yul åç«¯ |
| **022_backend_registry** | æ‰©å±• | ZK ä½œä¸ºæ–°çš„ç¼–è¯‘ç›®æ ‡ |

## 11. ç»“è®º

é€šè¿‡ Zig â†’ Noir è½¬è¯‘ï¼ŒTitan OS å°† ZK éšç§èƒ½åŠ›æ— ç¼èå…¥ç»Ÿä¸€å¼€å‘ä½“éªŒï¼š

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Titan ZK ä»·å€¼ä¸»å¼                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                           â”‚
â”‚  ğŸ”’ éšç§:    ä¸€ä»½ Zig ä»£ç  â†’ ZK ç”µè·¯ â†’ ä»»æ„é“¾ä¸ŠéªŒè¯                        â”‚
â”‚  ğŸŒ å¤šé“¾:    è‡ªåŠ¨ç”Ÿæˆ Solidity Verifierï¼Œéƒ¨ç½²åˆ°ä»»æ„ EVM é“¾                 â”‚
â”‚  ğŸ”§ ç»Ÿä¸€:    åˆçº¦ + ç”µè·¯ + å·¥å…·ï¼Œå…¨éƒ¨ç”¨ Zig                                â”‚
â”‚  ğŸš€ ç”Ÿæ€:    æ”¯æŒ Aztec Network åŸç”Ÿåº”ç”¨                                   â”‚
â”‚                                                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**æœ€ç»ˆæ•ˆæœ**: å¼€å‘è€…ç”¨ç†Ÿæ‚‰çš„ Zig ç¼–å†™éšç§åº”ç”¨ï¼ŒTitan è‡ªåŠ¨å¤„ç†è½¬è¯‘ã€ç¼–è¯‘ã€éƒ¨ç½²å…¨æµç¨‹ã€‚
